// Generated by CoffeeScript 1.6.3
(function() {
  var FullscreenQuad, GBuffer, Model, ResourceLoader, SceneCamera, SceneGraph, SceneLight, SceneNode, SceneObject, ShaderProgram, Texture, Xylem, getOrThrow,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Xylem = (function() {
    function Xylem(canvas) {
      this.sceneGraph = null;
      this.gl = this.initializeGL(canvas);
      this.setUpRendering(canvas);
      this.screenQuad = new FullscreenQuad(this.gl);
      this.drawFunction = this.draw;
      this.antiAliase = false;
      this.activeKeys = [];
      this.camera = null;
    }

    Xylem.prototype.activateKey = function(code) {
      return this.activeKeys[code] = true;
    };

    Xylem.prototype.clearKey = function(code) {
      return this.activeKeys[code] = false;
    };

    Xylem.prototype.toggleDrawType = function() {
      if (this.drawFunction === this.draw) {
        return this.drawFunction = this.drawWireframe;
      } else {
        return this.drawFunction = this.draw;
      }
    };

    Xylem.prototype.toggleAntiAliase = function() {
      return this.antiAliase = !this.antiAliase;
    };

    Xylem.prototype.initializeGL = function(canvas) {
      var gl;
      gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      gl || (function() {
        throw "Could not initialize WebGL.";
      })();
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      gl.clearColor(1.0, 1.0, 1.0, 1.0);
      gl.depthFunc(gl.LEQUAL);
      gl.getExtension('OES_texture_float') || (function() {
        throw "No floating point texture support.";
      })();
      gl.getExtension('OES_texture_float_linear') || (function() {
        throw "No linear filtering support for floating point textures.";
      })();
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      return gl;
    };

    Xylem.prototype.loadScene = function(scene, callback) {
      var _this = this;
      return this.loadSceneResources(scene, function(map, success) {
        return _this.setUpScene(scene, map, success, callback);
      });
    };

    Xylem.prototype.loadSceneResources = function(scene, callback) {
      var rl;
      rl = new ResourceLoader();
      return rl.load(scene.resources, callback);
    };

    Xylem.prototype.setUpScene = function(scene, resourceMap, loadSuccessful, callback) {
      var obj, objTraverse, objs, _i, _len,
        _this = this;
      this.resourceMap = resourceMap;
      if (!loadSuccessful) {
        throw "Not all necessary resources could be loaded.";
      }
      this.sceneGraph = new SceneGraph();
      objTraverse = function(parentNode, obj) {
        var childObj, model, node, type, _i, _len, _ref, _results;
        type = getOrThrow(obj, "type");
        node = null;
        if (type === "object") {
          node = new SceneObject();
          model = new Model(_this.gl);
          model.loadModel(_this.resourceMap[getOrThrow(obj, "model")]);
          node.setModel(model);
          if (obj.texture != null) {
            node.setTexture(new Texture.fromImage(_this.gl, _this.resourceMap[obj.texture]));
          }
          if (obj.scale != null) {
            node.scale(obj.scale);
          }
        } else if (type === "light") {
          node = new SceneLight();
          node.setDiffuseColor(getOrThrow(obj, "diffuseColor"));
          node.setSpecularColor(getOrThrow(obj, "specularColor"));
          node.setSpecularHardness(getOrThrow(obj, "specularHardness"));
          node.setConstantAttenuation(getOrThrow(obj, "constantAttenuation"));
          node.setLinearAttenuation(getOrThrow(obj, "linearAttenuation"));
          node.setQuadraticAttenuation(getOrThrow(obj, "quadraticAttenuation"));
        } else if (type === "camera") {
          node = new SceneCamera();
          node.setProperties(degreesToRadians(getOrThrow(obj, "fieldOfViewAngle")), _this.gl.viewportWidth, _this.gl.viewportHeight, getOrThrow(obj, "nearPlaneDistance"), getOrThrow(obj, "farPlaneDistance"));
        } else {
          throw "A node of an unsupported or unmarked type was found.";
        }
        parentNode.addChild(node);
        if (obj.translate != null) {
          node.translate(obj.translate);
        }
        if (obj.rotation != null) {
          node.rotate(degreesToRadians(getOrThrow(obj.rotation, "degrees")), getOrThrow(obj.rotation, "axis"));
        }
        if (obj.children != null) {
          _ref = obj.children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            childObj = _ref[_i];
            _results.push(objTraverse(node, childObj));
          }
          return _results;
        }
      };
      this.sceneGraph.setRoot(new SceneNode());
      objs = getOrThrow(scene, "tree");
      for (_i = 0, _len = objs.length; _i < _len; _i++) {
        obj = objs[_i];
        objTraverse(this.sceneGraph.getRoot(), obj);
      }
      this.camera = this.sceneGraph.getNodesOfType(SceneCamera)[0];
      return callback();
    };

    Xylem.prototype.setUpRendering = function(canvas) {
      this.gBuffer = new GBuffer(this.gl, [nextHighestPowerOfTwo(canvas.width), nextHighestPowerOfTwo(canvas.height)]);
      this.buffers = [new Texture(this.gl, [nextHighestPowerOfTwo(canvas.width), nextHighestPowerOfTwo(canvas.height)]), new Texture(this.gl, [nextHighestPowerOfTwo(canvas.width), nextHighestPowerOfTwo(canvas.height)])];
      this.currBuffer = 0;
      this.ambientProgram = new ShaderProgram(this.gl);
      this.ambientProgram.importShader("ambientPass_f");
      this.ambientProgram.importShader("ambientPass_v");
      this.ambientProgram.linkProgram();
      this.pointLightingProgram = new ShaderProgram(this.gl);
      this.pointLightingProgram.importShader("pointLightPass_f");
      this.pointLightingProgram.importShader("pointLightPass_v");
      this.pointLightingProgram.linkProgram();
      this.fxaaProgram = new ShaderProgram(this.gl);
      this.fxaaProgram.importShader("fxaaShader_f");
      this.fxaaProgram.importShader("fxaaShader_v");
      this.fxaaProgram.linkProgram();
      this.wireframeProgram = new ShaderProgram(this.gl);
      this.wireframeProgram.importShader("wireframe_f");
      this.wireframeProgram.importShader("wireframe_v");
      return this.wireframeProgram.linkProgram();
    };

    Xylem.prototype.switchBuffers = function() {
      return this.currBuffer = this.currBuffer ^ 1;
    };

    Xylem.prototype.draw = function() {
      var light, lightMVMatrix, lights, origin, pos, _i, _len,
        _this = this;
      lights = this.sceneGraph.getNodesOfType(SceneLight);
      origin = vec4.fromValues(0, 0, 0, 1);
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gBuffer.populate(function(shader) {
        return _this.sceneGraph.draw(shader, _this.camera);
      });
      this.gl.disable(this.gl.DEPTH_TEST);
      this.gBuffer.albedoTexture.bind(0);
      this.ambientProgram.enableProgram();
      this.ambientProgram.setUniform3f("ambientColor", [0.2, 0.2, 0.2]);
      this.ambientProgram.enableAttribute("vertexPosition");
      this.ambientProgram.enableAttribute("textureCoord");
      this.ambientProgram.setUniform1i("albedos", 0);
      this.buffers[this.currBuffer].drawTo(function() {
        _this.gl.clear(_this.gl.COLOR_BUFFER_BIT);
        return _this.screenQuad.draw(_this.ambientProgram);
      }, false);
      this.ambientProgram.disableAttribute("vertexPosition");
      this.ambientProgram.disableAttribute("textureCoord");
      this.gBuffer.normalsDepthTexture.bind(0);
      this.gBuffer.albedoTexture.bind(1);
      this.pointLightingProgram.enableProgram();
      this.pointLightingProgram.setUniform1f("farClip", this.camera.farClip);
      this.pointLightingProgram.setUniformMatrix4fv("pMatrix", this.camera.getInverseProjectionMatrix());
      this.pointLightingProgram.enableAttribute("vertexPosition");
      this.pointLightingProgram.enableAttribute("textureCoord");
      this.pointLightingProgram.setUniform1i("normals", 0);
      this.pointLightingProgram.setUniform1i("albedos", 1);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.ONE, this.gl.ONE);
      for (_i = 0, _len = lights.length; _i < _len; _i++) {
        light = lights[_i];
        pos = vec4.create();
        lightMVMatrix = mat4.create();
        mat4.multiply(lightMVMatrix, this.camera.getCumulativeViewMatrix(), light.getCumulativeModelMatrix());
        vec4.transformMat4(pos, origin, lightMVMatrix);
        light.setUniforms(this.pointLightingProgram, [pos[0], pos[1], pos[2]]);
        this.buffers[this.currBuffer].drawTo(function() {
          return _this.screenQuad.draw(_this.pointLightingProgram);
        }, false);
      }
      this.gl.disable(this.gl.BLEND);
      this.pointLightingProgram.disableAttribute("vertexPosition");
      this.pointLightingProgram.disableAttribute("textureCoord");
      if (this.antiAliase) {
        this.buffers[this.currBuffer].bind(0);
        this.fxaaProgram.enableProgram();
        this.fxaaProgram.setUniform1i("tex", 0);
        this.fxaaProgram.setUniform2f("viewportDimensions", [nextHighestPowerOfTwo(this.gl.viewportWidth), nextHighestPowerOfTwo(this.gl.viewportHeight)]);
        this.fxaaProgram.enableAttribute("vertexPosition");
        this.fxaaProgram.enableAttribute("textureCoord");
        this.switchBuffers();
        this.buffers[this.currBuffer].drawTo(function() {
          return _this.screenQuad.draw(_this.fxaaProgram);
        }, false);
        this.fxaaProgram.disableAttribute("vertexPosition");
        this.fxaaProgram.disableAttribute("textureCoord");
      }
      return this.screenQuad.drawWithTexture(this.buffers[this.currBuffer]);
    };

    Xylem.prototype.drawWireframe = function() {
      var _this = this;
      this.wireframeProgram.enableProgram();
      this.buffers[this.currBuffer].drawTo(function() {
        _this.gl.clear(_this.gl.COLOR_BUFFER_BIT | _this.gl.DEPTH_BUFFER_BIT);
        return _this.sceneGraph.drawWireframe(_this.wireframeProgram, _this.camera);
      }, true);
      return this.screenQuad.drawWithTexture(this.buffers[this.currBuffer]);
    };

    Xylem.prototype.mainLoop = function() {
      var _this = this;
      this.camera.updateStateFromActiveKeys(this.activeKeys);
      this.drawFunction();
      return browserVersionOf("requestAnimationFrame")(function() {
        return _this.mainLoop();
      });
    };

    return Xylem;

  })();

  window.Xylem = Xylem;

  Model = (function() {
    function Model(gl) {
      this.gl = gl;
      this.buffers = {
        vertexPositionBuffer: null,
        vertexNormalBuffer: null,
        vertexTextureCoordBuffer: null,
        indexBuffer: null
      };
      this.textureOpacity = null;
    }

    Model.prototype.loadModel = function(model) {
      var clr;
      clr = getOrThrow(model, "baseColor");
      this.baseColor = {
        "r": getOrThrow(clr, "r"),
        "g": getOrThrow(clr, "g"),
        "b": getOrThrow(clr, "b")
      };
      this.textureOpacity = getOrThrow(model, "textureOpacity");
      this.hasTexture = this.textureOpacity > 0;
      this.buffers.vertexNormalBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexNormalBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(model.vertexNormals), this.gl.STATIC_DRAW);
      this.buffers.vertexNormalBuffer.itemSize = 3;
      this.buffers.vertexNormalBuffer.numItems = model.vertexNormals.length / 3;
      this.buffers.vertexPositionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexPositionBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(model.vertexPositions), this.gl.STATIC_DRAW);
      this.buffers.vertexPositionBuffer.itemSize = 3;
      this.buffers.vertexPositionBuffer.numItems = model.vertexPositions.length / 3;
      if (this.hasTexture) {
        this.buffers.vertexTextureCoordBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexTextureCoordBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(model.vertexTextureCoords), this.gl.STATIC_DRAW);
        this.buffers.vertexTextureCoordBuffer.itemSize = 2;
        this.buffers.vertexTextureCoordBuffer.numItems = model.vertexTextureCoords.length / 2;
      }
      this.buffers.indexBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.indexBuffer);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(model.indices), this.gl.STATIC_DRAW);
      this.buffers.indexBuffer.itemSize = 1;
      return this.buffers.indexBuffer.numItems = model.indices.length;
    };

    Model.prototype.getBuffers = function() {
      return this.buffers;
    };

    Model.prototype.draw = function(shaderProgram, texture) {
      var bindLocation;
      shaderProgram.enableAttribute("vertexPosition");
      shaderProgram.enableAttribute("vertexNormal");
      if (this.hasTexture) {
        shaderProgram.enableAttribute("textureCoord");
      }
      shaderProgram.setUniform1f("textureOpacity", this.textureOpacity);
      shaderProgram.setUniform3f("baseColor", [this.baseColor.r, this.baseColor.g, this.baseColor.b]);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexPositionBuffer);
      this.gl.vertexAttribPointer(shaderProgram.getAttribute("vertexPosition"), this.buffers.vertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      if (this.hasTexture) {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexTextureCoordBuffer);
        this.gl.vertexAttribPointer(shaderProgram.getAttribute("textureCoord"), this.buffers.vertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      }
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexNormalBuffer);
      this.gl.vertexAttribPointer(shaderProgram.getAttribute("vertexNormal"), this.buffers.vertexNormalBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.indexBuffer);
      bindLocation = 0;
      if (this.hasTexture) {
        texture.bind(bindLocation);
        shaderProgram.setUniform1i("sampler", bindLocation);
      }
      this.gl.drawElements(this.gl.TRIANGLES, this.buffers.indexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
      if (this.hasTexture) {
        texture.unbind(bindLocation);
        shaderProgram.disableAttribute("textureCoord");
      }
      shaderProgram.disableAttribute("vertexPosition");
      return shaderProgram.disableAttribute("vertexNormal");
    };

    Model.prototype.drawLines = function(shaderProgram) {
      var i, _i, _ref;
      shaderProgram.enableAttribute("vertexPosition");
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.vertexPositionBuffer);
      this.gl.vertexAttribPointer(shaderProgram.getAttribute("vertexPosition"), this.buffers.vertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.indexBuffer);
      for (i = _i = 0, _ref = this.buffers.indexBuffer.numItems - 3; _i <= _ref; i = _i += 3) {
        this.gl.drawElements(this.gl.LINE_LOOP, 3, this.gl.UNSIGNED_SHORT, i * 2);
      }
      return shaderProgram.disableAttribute("vertexPosition");
    };

    return Model;

  })();

  Texture = (function() {
    function Texture(gl, dimensions, options) {
      this.gl = gl;
      this.dimensions = dimensions;
      options = options || {};
      this.id = this.gl.createTexture();
      this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, options.magFilter || this.gl.LINEAR);
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, options.minFilter || this.gl.LINEAR);
      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.dimensions[0], this.dimensions[1], 0, options.format || this.gl.RGBA, options.internalRepresentation || this.gl.UNSIGNED_BYTE, null);
      this.gl.bindTexture(this.gl.TEXTURE_2D, null);
      this.framebuffer = null;
      this.renderbuffer = null;
    }

    Texture.prototype.bind = function(number) {
      this.gl.activeTexture(this.gl.TEXTURE0 + (number || 0));
      return this.gl.bindTexture(this.gl.TEXTURE_2D, this.id);
    };

    Texture.prototype.unbind = function(number) {
      this.gl.activeTexture(this.gl.TEXTURE0 + (number || 0));
      return this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    };

    Texture.prototype.drawTo = function(drawCallback, useDepth) {
      var hold;
      if (useDepth == null) {
        useDepth = true;
      }
      hold = this.gl.getParameter(this.gl.VIEWPORT);
      this.framebuffer = this.framebuffer || this.gl.createFramebuffer();
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);
      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.id, 0);
      if (useDepth) {
        this.renderbuffer = this.renderbuffer || this.gl.createRenderbuffer();
        this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.renderbuffer);
        this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, this.dimensions[0], this.dimensions[1]);
        this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.renderbuffer);
      }
      this.gl.viewport(0, 0, this.dimensions[0], this.dimensions[1]);
      drawCallback();
      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
      return this.gl.viewport(hold[0], hold[1], hold[2], hold[3]);
    };

    Texture.prototype.swapContents = function(texture) {
      var hold;
      hold = texture.id;
      texture.id = this.id;
      this.id = hold;
      hold = texture.dimensions;
      texture.dimensions = this.dimensions;
      return this.dimensions = hold;
    };

    return Texture;

  })();

  Texture.fromImage = function(gl, image) {
    var texture;
    texture = new Texture(gl, [image.width, image.height]);
    gl.bindTexture(gl.TEXTURE_2D, texture.id);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.FLOAT, image);
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return texture;
  };

  ShaderProgram = (function() {
    function ShaderProgram(gl) {
      this.gl = gl;
      this.program = null;
      this.shaders = [];
      this.attributes = {};
    }

    ShaderProgram.prototype.importShader = function(id) {
      var glShader, node, script, shaderString;
      script = document.getElementById(id);
      if (!script) {
        throw "shader: " + id + " could not be found.";
      }
      shaderString = "";
      node = script.firstChild;
      while (node) {
        if (node.nodeType) {
          shaderString += node.textContent;
        }
        node = node.nextSibling;
      }
      if (script.type === "x-shader/x-fragment") {
        glShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      } else if (script.type === "x-shader/x-vertex") {
        glShader = this.gl.createShader(this.gl.VERTEX_SHADER);
      }
      this.gl.shaderSource(glShader, shaderString);
      this.gl.compileShader(glShader);
      if (!this.gl.getShaderParameter(glShader, this.gl.COMPILE_STATUS)) {
        throw "A shader would not compile.";
      }
      return this.shaders.push(glShader);
    };

    ShaderProgram.prototype.linkProgram = function() {
      var shader, _i, _len, _ref;
      this.program = this.gl.createProgram();
      _ref = this.shaders;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shader = _ref[_i];
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          throw "Shader hasn't been compiled.";
        }
        this.gl.attachShader(this.program, shader);
      }
      this.gl.linkProgram(this.program);
      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
        throw "Shader couldn't be linked.";
      }
    };

    ShaderProgram.prototype.enableProgram = function() {
      if (!this.program) {
        throw "ShaderProgram must be linked before enabling it.";
      }
      return this.gl.useProgram(this.program);
    };

    ShaderProgram.prototype.enableAttribute = function(name) {
      if (!this.program) {
        throw "ShaderProgram must be linked before enabling attribute.";
      }
      this.attributes[name] = this.gl.getAttribLocation(this.program, name);
      return this.gl.enableVertexAttribArray(this.attributes[name]);
    };

    ShaderProgram.prototype.disableAttribute = function(name) {
      return this.gl.disableVertexAttribArray(getOrThrow(this.attributes, name));
    };

    ShaderProgram.prototype.getAttribute = function(name) {
      return this.attributes[name];
    };

    ShaderProgram.prototype.setUniform1f = function(name, value) {
      return this.gl.uniform1f(this.gl.getUniformLocation(this.program, name), value);
    };

    ShaderProgram.prototype.setUniform1i = function(name, value) {
      return this.gl.uniform1i(this.gl.getUniformLocation(this.program, name), value);
    };

    ShaderProgram.prototype.setUniform2f = function(name, values) {
      return this.gl.uniform2f(this.gl.getUniformLocation(this.program, name), values[0], values[1]);
    };

    ShaderProgram.prototype.setUniform3f = function(name, values) {
      return this.gl.uniform3f(this.gl.getUniformLocation(this.program, name), values[0], values[1], values[2]);
    };

    ShaderProgram.prototype.setUniformMatrix3fv = function(name, matrix) {
      return this.gl.uniformMatrix3fv(this.gl.getUniformLocation(this.program, name), false, matrix);
    };

    ShaderProgram.prototype.setUniformMatrix4fv = function(name, matrix) {
      return this.gl.uniformMatrix4fv(this.gl.getUniformLocation(this.program, name), false, matrix);
    };

    return ShaderProgram;

  })();

  SceneNode = (function() {
    function SceneNode() {
      this.modelMatrix = mat4.create();
      this.cumulativeModelMatrix = mat4.create();
      this.children = [];
      this.parentNode = null;
      this.resetModelMatrix();
    }

    SceneNode.prototype.translate = function(vector) {
      return mat4.translate(this.modelMatrix, this.modelMatrix, vector);
    };

    SceneNode.prototype.rotate = function(radians, axis) {
      return mat4.rotate(this.modelMatrix, this.modelMatrix, radians, axis);
    };

    SceneNode.prototype.resetModelMatrix = function() {
      mat4.identity(this.modelMatrix);
      return mat4.identity(this.cumulativeModelMatrix);
    };

    SceneNode.prototype.getModelMatrix = function() {
      return this.modelMatrix;
    };

    SceneNode.prototype.getCumulativeModelMatrix = function() {
      return this.cumulativeModelMatrix;
    };

    SceneNode.prototype.accumulateModelMatrix = function(parentAccumulatedModelMatrix) {
      var node, _i, _len, _ref, _results;
      mat4.multiply(this.cumulativeModelMatrix, parentAccumulatedModelMatrix, this.modelMatrix);
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        _results.push(node.accumulateModelMatrix(this.cumulativeModelMatrix));
      }
      return _results;
    };

    SceneNode.prototype.addChild = function(node) {
      node.setParent(this);
      return this.children.push(node);
    };

    SceneNode.prototype.reparentTo = function(node) {
      if (this.parentNode) {
        this.parentNode.removeChild(this);
      }
      return node.addChild(this);
    };

    SceneNode.prototype.setParent = function(parentNode) {
      this.parentNode = parentNode;
    };

    SceneNode.prototype.removeChild = function(node) {
      var index;
      index = this.children.indexOf(node);
      if (index === -1) {
        return;
      }
      return this.children = this.children.slice(0, index) + this.children.slice(index + 1);
    };

    SceneNode.prototype.getChildren = function() {
      return this.children;
    };

    return SceneNode;

  })();

  SceneGraph = (function() {
    function SceneGraph() {
      this.rootNode = null;
    }

    SceneGraph.prototype.setRoot = function(rootNode) {
      this.rootNode = rootNode;
    };

    SceneGraph.prototype.getRoot = function() {
      return this.rootNode;
    };

    SceneGraph.prototype.getNodesOfType = function(type) {
      var list, preOrder;
      list = [];
      preOrder = function(node, type) {
        var child, _i, _len, _ref, _results;
        if (node instanceof type) {
          list.push(node);
        }
        _ref = node.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(preOrder(child, type));
        }
        return _results;
      };
      preOrder(this.rootNode, type);
      return list;
    };

    SceneGraph.prototype.actOnNodesOfType = function(type, act) {
      var preOrder;
      preOrder = function(node, type, act) {
        var child, _i, _len, _ref, _results;
        if (node instanceof type) {
          act(node);
        }
        _ref = node.children;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          _results.push(preOrder(child, type, act));
        }
        return _results;
      };
      return preOrder(this.rootNode, type, act);
    };

    SceneGraph.prototype.draw = function(shaderProgram, camera) {
      var startingModelMatrix;
      startingModelMatrix = mat4.create();
      mat4.identity(startingModelMatrix);
      this.rootNode.accumulateModelMatrix(startingModelMatrix);
      return this.actOnNodesOfType(SceneObject, function(object) {
        var mvMatrix, normalMatrix;
        mvMatrix = mat4.create();
        mat4.multiply(mvMatrix, camera.getCumulativeViewMatrix(), object.getCumulativeModelMatrix());
        shaderProgram.setUniformMatrix4fv("mvMatrix", mvMatrix);
        shaderProgram.setUniformMatrix4fv("pMatrix", camera.getProjectionMatrix());
        shaderProgram.setUniform1f("farClip", camera.farClip);
        normalMatrix = mat3.create();
        mat3.fromMat4(normalMatrix, mvMatrix);
        mat3.invert(normalMatrix, normalMatrix);
        mat3.transpose(normalMatrix, normalMatrix);
        shaderProgram.setUniformMatrix3fv("nMatrix", normalMatrix);
        return object.getGraphicalModel().draw(shaderProgram, object.getTexture());
      });
    };

    SceneGraph.prototype.drawWireframe = function(shaderProgram, camera) {
      var startingModelMatrix;
      startingModelMatrix = mat4.create();
      mat4.identity(startingModelMatrix);
      this.rootNode.accumulateModelMatrix(startingModelMatrix);
      return this.actOnNodesOfType(SceneObject, function(object) {
        var mvMatrix;
        mvMatrix = mat4.create();
        mat4.multiply(mvMatrix, camera.getCumulativeViewMatrix(), object.getCumulativeModelMatrix());
        shaderProgram.setUniformMatrix4fv("mvMatrix", mvMatrix);
        shaderProgram.setUniformMatrix4fv("pMatrix", camera.getProjectionMatrix());
        return object.getGraphicalModel().drawLines(shaderProgram);
      });
    };

    return SceneGraph;

  })();

  ResourceLoader = (function() {
    function ResourceLoader() {
      this.barrier = new CallbackBarrier();
      this.resources = {};
      this.failures = false;
    }

    ResourceLoader.prototype.load = function(loadRules, resourceReturnCallback) {
      var rule, _i, _len,
        _this = this;
      for (_i = 0, _len = loadRules.length; _i < _len; _i++) {
        rule = loadRules[_i];
        if (rule["type"] === "image") {
          this.loadImage(rule.name, rule.url, this.barrier.getCallback());
        } else if (rule["type"] === "text") {
          this.loadText(rule.name, rule.url, this.barrier.getCallback());
        } else if (rule["type"] === "json") {
          this.loadJSON(rule.name, rule.url, this.barrier.getCallback());
        } else {
          throw "Invalid load rule type.";
        }
      }
      return this.barrier.finalize(function() {
        return resourceReturnCallback(_this.resources, !_this.failures);
      });
    };

    ResourceLoader.prototype.loadImage = function(name, url, callback) {
      var image,
        _this = this;
      image = new Image();
      image.onload = function() {
        _this.resources[name] = image;
        return callback();
      };
      image.onerror = function() {
        _this.resources[name] = null;
        _this.failures = true;
        return callback();
      };
      return image.src = url;
    };

    ResourceLoader.prototype.loadText = function(name, url, callback) {
      var httpRequest,
        _this = this;
      httpRequest = new XMLHttpRequest();
      httpRequest.addEventListener("readystatechange", function() {
        if (httpRequest.readyState !== 4) {
          return null;
        }
        if (httpRequest.status === 200) {
          _this.resources[name] = httpRequest.responseText;
          return callback();
        } else {
          _this.resources[name] = null;
          _this.failures = true;
          return callback();
        }
      });
      httpRequest.open("GET", url, true);
      return httpRequest.send();
    };

    ResourceLoader.prototype.loadJSON = function(name, url, callback) {
      var httpRequest,
        _this = this;
      httpRequest = new XMLHttpRequest();
      httpRequest.addEventListener("readystatechange", function() {
        if (httpRequest.readyState !== 4) {
          return null;
        }
        if (httpRequest.status === 200) {
          _this.resources[name] = JSON.parse(httpRequest.responseText);
          return callback();
        } else {
          _this.resources[name] = null;
          _this.failures = true;
          return callback();
        }
      });
      httpRequest.open("GET", url, true);
      return httpRequest.send();
    };

    return ResourceLoader;

  })();

  SceneObject = (function(_super) {
    __extends(SceneObject, _super);

    function SceneObject() {
      SceneObject.__super__.constructor.call(this);
      this.graphicalModel = null;
      this.texture = null;
    }

    SceneObject.prototype.scale = function(proportion) {
      return mat4.scale(this.modelMatrix, this.modelMatrix, proportion);
    };

    SceneObject.prototype.setModel = function(graphicalModel) {
      this.graphicalModel = graphicalModel;
    };

    SceneObject.prototype.getGraphicalModel = function() {
      return this.graphicalModel;
    };

    SceneObject.prototype.setTexture = function(texture) {
      this.texture = texture;
      return null;
    };

    SceneObject.prototype.getTexture = function() {
      return this.texture;
    };

    return SceneObject;

  })(SceneNode);

  SceneLight = (function(_super) {
    __extends(SceneLight, _super);

    function SceneLight(type) {
      SceneLight.__super__.constructor.call(this);
      if (type != null) {
        this.type = type;
      } else {
        this.type = "point";
      }
      this.diffuseColor = null;
      this.specularColor = null;
      this.specularHardness = null;
      this.constantAttenuation = null;
      this.linearAttenuation = null;
      this.quadraticAttenuation = null;
    }

    SceneLight.prototype.setAmbientColor = function(ambientColor) {
      this.ambientColor = ambientColor;
    };

    SceneLight.prototype.getAmbientColor = function() {
      return this.ambientColor;
    };

    SceneLight.prototype.setDiffuseColor = function(diffuseColor) {
      this.diffuseColor = diffuseColor;
    };

    SceneLight.prototype.getDiffuseColor = function() {
      return this.diffuseColor;
    };

    SceneLight.prototype.setSpecularColor = function(specularColor) {
      this.specularColor = specularColor;
    };

    SceneLight.prototype.getSpecularColor = function() {
      return this.specularColor;
    };

    SceneLight.prototype.setSpecularHardness = function(specularHardness) {
      this.specularHardness = specularHardness;
    };

    SceneLight.prototype.getSpecularHardness = function() {
      return this.specularHardness;
    };

    SceneLight.prototype.setConstantAttenuation = function(constantAttenuation) {
      this.constantAttenuation = constantAttenuation;
    };

    SceneLight.prototype.getConstantAttenuation = function() {
      return this.constantAttenuation;
    };

    SceneLight.prototype.setLinearAttenuation = function(linearAttenuation) {
      this.linearAttenuation = linearAttenuation;
    };

    SceneLight.prototype.getLinearAttenuation = function() {
      return this.linearAttenuation;
    };

    SceneLight.prototype.setQuadraticAttenuation = function(quadraticAttenuation) {
      this.quadraticAttenuation = quadraticAttenuation;
    };

    SceneLight.prototype.getQuadraticAttenuation = function() {
      return this.quadraticAttenuation;
    };

    SceneLight.prototype.setUniforms = function(shaderProgram, translation) {
      shaderProgram.setUniform3f("pointLightDiffuseColor", this.diffuseColor);
      shaderProgram.setUniform3f("pointLightSpecularColor", this.specularColor);
      shaderProgram.setUniform3f("pointLightLocation", translation);
      shaderProgram.setUniform1f("specularHardness", this.specularHardness);
      shaderProgram.setUniform1f("constantAttenuation", this.constantAttenuation);
      shaderProgram.setUniform1f("linearAttenuation", this.linearAttenuation);
      return shaderProgram.setUniform1f("quadraticAttenuation", this.quadraticAttenuation);
    };

    return SceneLight;

  })(SceneNode);

  SceneCamera = (function(_super) {
    __extends(SceneCamera, _super);

    function SceneCamera() {
      SceneCamera.__super__.constructor.call(this);
      this.viewMatrix = mat4.create();
      this.projectionMatrix = mat4.create();
      this.cumulativeViewMatrix = mat4.create();
      this.inverseProjectionMatrix = mat4.create();
    }

    SceneCamera.prototype.setProperties = function(fov, viewportWidth, viewportHeight, nearClip, farClip) {
      this.nearClip = nearClip;
      this.farClip = farClip;
      mat4.perspective(this.projectionMatrix, fov, viewportWidth / viewportHeight, nearClip, farClip);
      return mat4.invert(this.inverseProjectionMatrix, this.projectionMatrix);
    };

    SceneCamera.prototype.getProjectionMatrix = function() {
      return this.projectionMatrix;
    };

    SceneCamera.prototype.getInverseProjectionMatrix = function() {
      return this.inverseProjectionMatrix;
    };

    SceneCamera.prototype.getViewMatrix = function() {
      this.recalculateViewMatrix();
      return this.viewMatrix;
    };

    SceneCamera.prototype.recalculateViewMatrix = function() {
      return mat4.invert(this.viewMatrix, this.modelMatrix);
    };

    SceneCamera.prototype.getCumulativeViewMatrix = function() {
      mat4.invert(this.cumulativeViewMatrix, this.cumulativeModelMatrix);
      return this.cumulativeViewMatrix;
    };

    SceneCamera.prototype.updateStateFromActiveKeys = function(activeKeys) {
      var axis, radians, translation;
      translation = [0, 0, 0];
      if (!!activeKeys[87]) {
        translation[2] = -0.1;
      }
      if (!!activeKeys[83]) {
        translation[2] = 0.1;
      }
      if (!!activeKeys[65]) {
        translation[0] = -0.1;
      }
      if (!!activeKeys[68]) {
        translation[0] = 0.1;
      }
      this.translate(translation);
      axis = [1, 0, 0];
      radians = 0;
      if (!!activeKeys[73]) {
        radians = 0.03;
      }
      if (!!activeKeys[75]) {
        radians = -0.03;
      }
      if (radians !== 0) {
        this.rotate(radians, axis);
      }
      axis = [0, 1, 0];
      radians = 0;
      if (!!activeKeys[74]) {
        radians = 0.03;
      }
      if (!!activeKeys[76]) {
        radians = -0.03;
      }
      if (radians !== 0) {
        this.rotate(radians, axis);
      }
      axis = [0, 0, 1];
      radians = 0;
      if (!!activeKeys[85]) {
        radians = 0.03;
      }
      if (!!activeKeys[79]) {
        radians = -0.03;
      }
      if (radians !== 0) {
        return this.rotate(radians, axis);
      }
    };

    return SceneCamera;

  })(SceneNode);

  getOrThrow = function(obj, field) {
    if (obj[field] == null) {
      throw new ReferenceError("Object doesn't have '" + field + "' field.");
    }
    return obj[field];
  };

  FullscreenQuad = (function() {
    function FullscreenQuad(gl) {
      var indices, vertexPositions, vertexTextureCoords;
      this.gl = gl;
      vertexPositions = [-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0];
      vertexTextureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
      indices = [0, 1, 2, 0, 2, 3];
      this.vertexPositionBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexPositionBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexPositions), this.gl.STATIC_DRAW);
      this.vertexPositionBuffer.itemSize = 3;
      this.vertexPositionBuffer.numItems = vertexPositions.length / 3;
      this.vertexTextureCoordBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoords), this.gl.STATIC_DRAW);
      this.vertexTextureCoordBuffer.itemSize = 2;
      this.vertexTextureCoordBuffer.numItems = vertexTextureCoords.length / 2;
      this.indexBuffer = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), this.gl.STATIC_DRAW);
      this.indexBuffer.itemSize = 1;
      this.indexBuffer.numItems = indices.length;
      this.blitProgram = new ShaderProgram(this.gl);
      this.blitProgram.importShader("blitShader_f");
      this.blitProgram.importShader("blitShader_v");
      this.blitProgram.linkProgram();
    }

    FullscreenQuad.prototype.draw = function(shaderProgram) {
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexPositionBuffer);
      this.gl.vertexAttribPointer(shaderProgram.getAttribute("vertexPosition"), this.vertexPositionBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
      this.gl.vertexAttribPointer(shaderProgram.getAttribute("textureCoord"), this.vertexTextureCoordBuffer.itemSize, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
      return this.gl.drawElements(this.gl.TRIANGLES, this.indexBuffer.numItems, this.gl.UNSIGNED_SHORT, 0);
    };

    FullscreenQuad.prototype.drawWithTexture = function(texture) {
      this.blitProgram.enableProgram();
      this.blitProgram.enableAttribute("vertexPosition");
      this.blitProgram.enableAttribute("textureCoord");
      texture.bind(0);
      this.blitProgram.setUniform1i("sampler", 0);
      this.draw(this.blitProgram);
      this.blitProgram.disableAttribute("vertexPosition");
      return this.blitProgram.disableAttribute("textureCoord");
    };

    return FullscreenQuad;

  })();

  GBuffer = (function() {
    function GBuffer(gl, dimensions) {
      this.gl = gl;
      this.normalsDepthTexture = new Texture(this.gl, dimensions, {
        internalRepresentation: this.gl.FLOAT
      });
      this.albedoTexture = new Texture(this.gl, dimensions);
      this.normalsDepthProgram = new ShaderProgram(this.gl);
      this.normalsDepthProgram.importShader("generateNormalsAndDepth_f");
      this.normalsDepthProgram.importShader("generateNormalsAndDepth_v");
      this.normalsDepthProgram.linkProgram();
      this.albedoProgram = new ShaderProgram(this.gl);
      this.albedoProgram.importShader("generateAlbedo_f");
      this.albedoProgram.importShader("generateAlbedo_v");
      this.albedoProgram.linkProgram();
    }

    GBuffer.prototype.populate = function(drawWithShader) {
      var _this = this;
      this.normalsDepthProgram.enableProgram();
      this.normalsDepthTexture.drawTo(function() {
        _this.gl.clear(_this.gl.COLOR_BUFFER_BIT | _this.gl.DEPTH_BUFFER_BIT);
        return drawWithShader(_this.normalsDepthProgram);
      }, true);
      this.albedoProgram.enableProgram();
      return this.albedoTexture.drawTo(function() {
        _this.gl.clear(_this.gl.COLOR_BUFFER_BIT | _this.gl.DEPTH_BUFFER_BIT);
        return drawWithShader(_this.albedoProgram);
      }, true);
    };

    return GBuffer;

  })();

}).call(this);
